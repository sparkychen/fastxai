<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ•°æ®è¡€ç¼˜å…³ç³»å¯è§†åŒ– - å¸†è½¯ETLé£æ ¼</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 25px;
            padding: 20px;
            background: linear-gradient(135deg, #1e6bdd 0%, #0d4ba3 100%);
            color: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            font-size: 2.2rem;
            margin-bottom: 8px;
            font-weight: 600;
        }
        
        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
            font-weight: 400;
        }
        
        .tabs {
            display: flex;
            margin-bottom: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            overflow: hidden;
        }
        
        .tab {
            flex: 1;
            padding: 16px;
            text-align: center;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
            font-size: 1rem;
            color: #666;
        }
        
        .tab.active {
            background-color: #f0f7ff;
            border-bottom: 3px solid #1e6bdd;
            color: #1e6bdd;
        }
        
        .tab:hover:not(.active) {
            background-color: #f8fafc;
        }
        
        .view-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            padding: 20px;
            margin-bottom: 25px;
            min-height: 600px;
        }
        
        .view {
            display: none;
        }
        
        .view.active {
            display: block;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8fafc;
            border-radius: 6px;
            border: 1px solid #e1e8f0;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-color {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.1);
        }
        
        .controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 12px;
        }
        
        .search-box {
            flex: 1;
            min-width: 280px;
            padding: 10px 15px;
            border: 1px solid #d1d9e6;
            border-radius: 6px;
            font-size: 0.95rem;
            transition: all 0.3s;
        }
        
        .search-box:focus {
            outline: none;
            border-color: #1e6bdd;
            box-shadow: 0 0 0 2px rgba(30, 107, 221, 0.1);
        }
        
        .btn {
            padding: 10px 20px;
            background-color: #1e6bdd;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.3s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .btn:hover {
            background-color: #0d5ac6;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1);
        }
        
        .btn-secondary {
            background-color: #64748b;
        }
        
        .btn-secondary:hover {
            background-color: #475569;
        }
        
        .node {
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .node:hover {
            filter: brightness(1.05);
            transform: translateY(-2px);
        }
        
        .node-header {
            fill: white;
            font-size: 11px;
            font-weight: 600;
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: central;
        }
        
        .node-body {
            fill: white;
            stroke: #d1d9e6;
            stroke-width: 1.5;
            rx: 4;
            ry: 4;
        }
        
        .node-text {
            font-size: 12px;
            font-weight: 500;
            pointer-events: none;
            text-anchor: middle;
            fill: #333;
        }
        
        .link {
            stroke: #a0aec0;
            stroke-width: 1.8;
            fill: none;
        }
        
        .tooltip {
            position: absolute;
            padding: 10px;
            background: rgba(30, 41, 59, 0.9);
            color: white;
            border-radius: 6px;
            pointer-events: none;
            font-size: 13px;
            max-width: 280px;
            z-index: 100;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.15);
            line-height: 1.5;
        }
        
        .instructions {
            margin-top: 18px;
            padding: 15px;
            background: #f0f7ff;
            border-radius: 6px;
            font-size: 0.85rem;
            border-left: 4px solid #1e6bdd;
        }
        
        footer {
            text-align: center;
            margin-top: 25px;
            padding: 18px;
            color: #64748b;
            font-size: 0.85rem;
        }
        
        .chart-container {
            width: 100%;
            height: 580px;
            border: 1px solid #e1e8f0;
            border-radius: 8px;
            overflow: hidden;
            background: #f8fafc;
            position: relative;
        }
        
        svg {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        .file-icon {
            font-size: 11px;
            fill: #475569;
        }
        
        .zoom-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .zoom-btn {
            width: 32px;
            height: 32px;
            background: white;
            border: 1px solid #d1d9e6;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 16px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .zoom-btn:hover {
            background: #f0f7ff;
        }
        
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            font-size: 16px;
            color: #64748b;
        }
        
        .error {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            font-size: 16px;
            color: #e11d48;
            flex-direction: column;
            gap: 10px;
        }
        
        .api-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            margin-bottom: 15px;
        }
        
        .status-connected {
            background: #f0f9ff;
            color: #0369a1;
            border: 1px solid #bae6fd;
        }
        
        .status-disconnected {
            background: #fef2f2;
            color: #dc2626;
            border: 1px solid #fecaca;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        
        .connected {
            background: #10b981;
        }
        
        .disconnected {
            background: #ef4444;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>æ•°æ®è¡€ç¼˜å…³ç³»å¯è§†åŒ–</h1>
            <p class="subtitle">è¡¨çº§è¡€ç¼˜è§†å›¾ & ETLæµç¨‹æº¯æºè§†å›¾</p>
        </header>
        
        <div class="api-status status-disconnected" id="api-status">
            <div class="status-dot disconnected"></div>
            <span>æ­£åœ¨è¿æ¥FastAPIåç«¯...</span>
        </div>
        
        <div class="tabs">
            <div class="tab active" data-view="table-lineage">è¡¨çº§è¡€ç¼˜è§†å›¾</div>
            <div class="tab" data-view="etl-lineage">ETLæµç¨‹æº¯æºè§†å›¾</div>
        </div>
        
        <div class="controls">
            <input type="text" class="search-box" placeholder="æœç´¢è¡¨åæˆ–ETLæµç¨‹..." id="search-input">
            <button class="btn" id="refresh-data">åˆ·æ–°æ•°æ®</button>
            <button class="btn" id="reset-view">é‡ç½®è§†å›¾</button>
        </div>
        
        <div class="view-container">
            <div class="view active" id="table-lineage">
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #10b981;"></div>
                        <span>æºè¡¨/æ–‡ä»¶</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #3b82f6;"></div>
                        <span>ä¸­é—´è¡¨</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #f59e0b;"></div>
                        <span>ç›®æ ‡è¡¨</span>
                    </div>
                </div>
                <div class="chart-container" id="table-lineage-chart">
                    <div class="loading">æ­£åœ¨åŠ è½½è¡¨çº§è¡€ç¼˜æ•°æ®...</div>
                </div>
                <div class="instructions">
                    <p><strong>ä½¿ç”¨è¯´æ˜ï¼š</strong> æ‹–åŠ¨èŠ‚ç‚¹å¯ä»¥é‡æ–°å¸ƒå±€ï¼Œæ‹–åŠ¨ç”»å¸ƒå¯ä»¥å¹³ç§»è§†å›¾ï¼Œä½¿ç”¨é¼ æ ‡æ»šè½®æˆ–ä¸Šæ–¹æŒ‰é’®å¯ä»¥ç¼©æ”¾è§†å›¾ï¼Œç‚¹å‡»èŠ‚ç‚¹å¯ä»¥æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯ã€‚</p>
                </div>
            </div>
            
            <div class="view" id="etl-lineage">
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #10b981;"></div>
                        <span>è¡¨èŠ‚ç‚¹</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #8b5cf6;"></div>
                        <span>ETLæµç¨‹èŠ‚ç‚¹</span>
                    </div>
                </div>
                <div class="chart-container" id="etl-lineage-chart">
                    <div class="loading">æ­£åœ¨åŠ è½½ETLæµç¨‹æº¯æºæ•°æ®...</div>
                </div>
                <div class="instructions">
                    <p><strong>ä½¿ç”¨è¯´æ˜ï¼š</strong> æ‹–åŠ¨èŠ‚ç‚¹å¯ä»¥é‡æ–°å¸ƒå±€ï¼Œæ‹–åŠ¨ç”»å¸ƒå¯ä»¥å¹³ç§»è§†å›¾ï¼Œä½¿ç”¨é¼ æ ‡æ»šè½®æˆ–ä¸Šæ–¹æŒ‰é’®å¯ä»¥ç¼©æ”¾è§†å›¾ï¼Œç‚¹å‡»èŠ‚ç‚¹å¯ä»¥æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯ã€‚</p>
                </div>
            </div>
        </div>
        
        <footer>
            <p>æ•°æ®è¡€ç¼˜å…³ç³»å¯è§†åŒ–ç³»ç»Ÿ &copy; 2025 | åç«¯API: <span id="api-url">http://localhost:8000</span></p>
        </footer>
    </div>

    <script>
        // FastAPIåç«¯é…ç½®
        const API_BASE_URL = 'http://localhost:9888/jjxxzx';
        const ENDPOINTS = {
            TABLE_LINEAGE: '/lineage/api/table',
            ETL_LINEAGE: '/lineage/api/etl',
            HEALTH: '/health'
        };

        // å…¨å±€å˜é‡
        let lineageData = {
            table: [],
            etl: []
        };
        
        // APIçŠ¶æ€ç®¡ç†
        function updateApiStatus(connected) {
            const statusElement = document.getElementById('api-status');
            const statusDot = statusElement.querySelector('.status-dot');
            const statusText = statusElement.querySelector('span');
            
            if (connected) {
                statusElement.className = 'api-status status-connected';
                statusDot.className = 'status-dot connected';
                statusText.textContent = 'å·²è¿æ¥åˆ°FastAPIåç«¯';
            } else {
                statusElement.className = 'api-status status-disconnected';
                statusDot.className = 'status-dot disconnected';
                statusText.textContent = 'æ— æ³•è¿æ¥åˆ°FastAPIåç«¯';
            }
        }
        
        // æ£€æŸ¥APIè¿æ¥çŠ¶æ€
        async function checkApiConnection() {
            try {
                const response = await fetch(`${API_BASE_URL}${ENDPOINTS.HEALTH}`);
                if (response.ok) {
                    updateApiStatus(true);
                    return true;
                } else {
                    updateApiStatus(false);
                    return false;
                }
            } catch (error) {
                console.error('APIè¿æ¥æ£€æŸ¥å¤±è´¥:', error);
                updateApiStatus(false);
                return false;
            }
        }
        
        // ä»FastAPIè·å–è¡¨çº§è¡€ç¼˜æ•°æ®
        async function fetchTableLineageData() {
            try {
                const response = await fetch(`${API_BASE_URL}${ENDPOINTS.TABLE_LINEAGE}/dws.tb_aggr`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('è·å–è¡¨çº§è¡€ç¼˜æ•°æ®å¤±è´¥:', error);
                throw error;
            }
        }
        
        // ä»FastAPIè·å–ETLæµç¨‹æº¯æºæ•°æ®
        async function fetchETLLineageData() {
            try {
                const response = await fetch(`${API_BASE_URL}${ENDPOINTS.ETL_LINEAGE}/xx`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('è·å–ETLæµç¨‹æº¯æºæ•°æ®å¤±è´¥:', error);
                throw error;
            }
        }
        
        // åŠ è½½æ‰€æœ‰æ•°æ®
        async function loadAllData() {
            const tableContainer = document.getElementById('table-lineage-chart');
            const etlContainer = document.getElementById('etl-lineage-chart');
            
            try {
                // æ£€æŸ¥APIè¿æ¥
                const isConnected = await checkApiConnection();
                if (!isConnected) {
                    tableContainer.innerHTML = '<div class="error">æ— æ³•è¿æ¥åˆ°FastAPIåç«¯ï¼Œè¯·æ£€æŸ¥æœåŠ¡æ˜¯å¦è¿è¡Œ</div>';
                    etlContainer.innerHTML = '<div class="error">æ— æ³•è¿æ¥åˆ°FastAPIåç«¯ï¼Œè¯·æ£€æŸ¥æœåŠ¡æ˜¯å¦è¿è¡Œ</div>';
                    return;
                }
                
                // åŠ è½½è¡¨çº§è¡€ç¼˜æ•°æ®
                tableContainer.innerHTML = '<div class="loading">æ­£åœ¨åŠ è½½è¡¨çº§è¡€ç¼˜æ•°æ®...</div>';
                lineageData.table = await fetchTableLineageData();
                
                // åŠ è½½ETLæµç¨‹æº¯æºæ•°æ®
                etlContainer.innerHTML = '<div class="loading">æ­£åœ¨åŠ è½½ETLæµç¨‹æº¯æºæ•°æ®...</div>';
                lineageData.etl = await fetchETLLineageData();
                
                // æ¸²æŸ“åˆå§‹è§†å›¾
                renderTableLineage();
                
            } catch (error) {
                console.error('æ•°æ®åŠ è½½å¤±è´¥:', error);
                tableContainer.innerHTML = '<div class="error">æ•°æ®åŠ è½½å¤±è´¥: ' + error.message + '</div>';
                etlContainer.innerHTML = '<div class="error">æ•°æ®åŠ è½½å¤±è´¥: ' + error.message + '</div>';
            }
        }
        
        // æ ‡ç­¾åˆ‡æ¢åŠŸèƒ½
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', function() {
                // ç§»é™¤æ‰€æœ‰activeç±»
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
                
                // æ·»åŠ activeç±»åˆ°å½“å‰æ ‡ç­¾
                this.classList.add('active');
                const viewId = this.getAttribute('data-view');
                document.getElementById(viewId).classList.add('active');
                
                // é‡æ–°æ¸²æŸ“å›¾è¡¨
                if (viewId === 'table-lineage') {
                    renderTableLineage();
                } else {
                    renderETLLineage();
                }
            });
        });

        // è¡¨çº§è¡€ç¼˜è§†å›¾
        function renderTableLineage() {
            const container = document.getElementById('table-lineage-chart');
            
            // æ£€æŸ¥æ•°æ®æ˜¯å¦å·²åŠ è½½
            if (!lineageData.table || lineageData.table.length === 0) {
                container.innerHTML = '<div class="error">è¡¨çº§è¡€ç¼˜æ•°æ®ä¸ºç©º</div>';
                return;
            }
            
            container.innerHTML = '';
            
            // æ·»åŠ ç¼©æ”¾æ§åˆ¶æŒ‰é’®
            const zoomControls = document.createElement('div');
            zoomControls.className = 'zoom-controls';
            zoomControls.innerHTML = `
                <button class="zoom-btn" id="zoom-in">+</button>
                <button class="zoom-btn" id="zoom-out">-</button>
                <button class="zoom-btn" id="reset-zoom">â†º</button>
            `;
            container.appendChild(zoomControls);
            
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            const svg = d3.select('#table-lineage-chart')
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            // åˆ›å»ºç¼©æ”¾å’Œå¹³ç§»å®¹å™¨
            const g = svg.append('g');
            
            // å¤„ç†æ•°æ® - æ„å»ºèŠ‚ç‚¹å’Œè¾¹
            const nodes = [];
            const links = [];
            const nodeMap = new Map();
            
            // è®¡ç®—èŠ‚ç‚¹å±‚çº§
            const nodeLevels = {};
            const maxLevels = 6;
            
            // åˆå§‹åŒ–æ‰€æœ‰èŠ‚ç‚¹
            lineageData.table.forEach(record => {
                if (!nodeMap.has(record.source_table)) {
                    const nodeType = record.source_type === 'file' ? 'source' : 
                                    record.source_table.includes('dws.') ? 'target' : 'intermediate';
                    
                    // æ–‡ä»¶ç±»å‹èŠ‚ç‚¹æ˜¾ç¤ºå®Œæ•´æ–‡ä»¶åå’Œç±»å‹
                    let displayName = record.source_table;
                    if (record.source_type === 'file') {
                        displayName = record.source_table; // æ˜¾ç¤ºå®Œæ•´æ–‡ä»¶åï¼Œå¦‚test.csv
                    } else if (record.source_table.includes('.')) {
                        displayName = record.source_table.split('.')[1];
                    }
                    
                    nodes.push({
                        id: record.source_table,
                        name: record.source_table,
                        displayName: displayName,
                        type: nodeType,
                        nodeType: 'table',
                        source_type: record.source_type
                    });
                    nodeMap.set(record.source_table, true);
                }
                
                if (!nodeMap.has(record.target_table)) {
                    const nodeType = record.target_table.includes('dws.') ? 'target' : 'intermediate';
                    nodes.push({
                        id: record.target_table,
                        name: record.target_table,
                        displayName: record.target_table.includes('.') ? 
                                    record.target_table.split('.')[1] : record.target_table,
                        type: nodeType,
                        nodeType: 'table',
                        source_type: 'table'
                    });
                    nodeMap.set(record.target_table, true);
                }
            });
            
            // è®¡ç®—æ¯ä¸ªèŠ‚ç‚¹çš„å±‚çº§ï¼ˆä»æºå¤´å¼€å§‹ï¼‰
            function calculateLevels() {
                // åˆå§‹åŒ–å±‚çº§
                nodes.forEach(node => {
                    nodeLevels[node.id] = -1;
                });
                
                // æ‰¾åˆ°æ‰€æœ‰æºå¤´èŠ‚ç‚¹ï¼ˆæ²¡æœ‰è¾“å…¥è¾¹çš„èŠ‚ç‚¹ï¼‰
                const sourceNodes = nodes.filter(node => {
                    return !lineageData.table.some(record => record.target_table === node.id);
                });
                
                // ä»æºå¤´èŠ‚ç‚¹å¼€å§‹åˆ†é…å±‚çº§
                sourceNodes.forEach(node => {
                    nodeLevels[node.id] = 0;
                    propagateDownstream(node.id, 0);
                });
                
                // å¤„ç†å¯èƒ½é—æ¼çš„èŠ‚ç‚¹
                nodes.forEach(node => {
                    if (nodeLevels[node.id] === -1) {
                        // æ‰¾åˆ°æœ€å°å¯èƒ½çš„å±‚çº§
                        const incomingRecords = lineageData.table.filter(record => record.target_table === node.id);
                        if (incomingRecords.length > 0) {
                            const minSourceLevel = Math.min(...incomingRecords.map(record => nodeLevels[record.source_table]));
                            nodeLevels[node.id] = minSourceLevel + 1;
                            propagateDownstream(node.id, minSourceLevel + 1);
                        } else {
                            nodeLevels[node.id] = 0;
                        }
                    }
                });
                
                // å‘ä¸‹æ¸¸ä¼ æ’­å±‚çº§
                function propagateDownstream(table, level) {
                    if (level > maxLevels) return;
                    
                    lineageData.table.forEach(record => {
                        if (record.source_table === table && nodeLevels[record.target_table] < level + 1) {
                            nodeLevels[record.target_table] = level + 1;
                            propagateDownstream(record.target_table, level + 1);
                        }
                    });
                }
            }
            
            calculateLevels();
            
            // æ·»åŠ è¾¹
            lineageData.table.forEach(record => {
                // æ‰¾åˆ°æºèŠ‚ç‚¹å’Œç›®æ ‡èŠ‚ç‚¹å¯¹è±¡
                const sourceNode = nodes.find(n => n.id === record.source_table);
                const targetNode = nodes.find(n => n.id === record.target_table);
                
                if (sourceNode && targetNode) {
                    links.push({
                        source: sourceNode,
                        target: targetNode,
                        etl_desc: record.etl_desc,
                        created_at: record.created_at
                    });
                }
            });
            
            // è®¾ç½®èŠ‚ç‚¹ä½ç½®ï¼ˆæŒ‰å±‚çº§ä»å·¦åˆ°å³æ’åˆ—ï¼‰
            const levelWidth = width / (maxLevels + 1);
            const levelPositions = {};
            
            nodes.forEach(node => {
                const level = nodeLevels[node.id] !== undefined ? nodeLevels[node.id] : 0;
                if (!levelPositions[level]) levelPositions[level] = [];
                levelPositions[level].push(node);
            });
            
            // ä¸ºæ¯ä¸ªå±‚çº§çš„èŠ‚ç‚¹åˆ†é…Yåæ ‡
            Object.keys(levelPositions).forEach(level => {
                const nodesInLevel = levelPositions[level];
                const levelHeight = height / (nodesInLevel.length + 1);
                
                nodesInLevel.forEach((node, index) => {
                    node.x = level * levelWidth + levelWidth / 2;
                    node.y = (index + 1) * levelHeight;
                    node.fx = node.x;
                    node.fy = node.y;
                });
            });
            
            // åˆ›å»ºç®­å¤´æ ‡è®°
            svg.append('defs').selectAll('marker')
                .data(['arrowhead'])
                .enter().append('marker')
                .attr('id', d => d)
                .attr('viewBox', '0 -5 10 10')
                .attr('refX', 15)
                .attr('refY', 0)
                .attr('markerWidth', 6)
                .attr('markerHeight', 6)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M0,-5L10,0L0,5')
                .attr('fill', '#a0aec0');
            
            // åˆ›å»ºè¾¹
            const link = g.append('g')
                .attr('class', 'links')
                .selectAll('line')
                .data(links)
                .enter()
                .append('line')
                .attr('class', 'link')
                .attr('marker-end', 'url(#arrowhead)');
            
            // åˆ›å»ºèŠ‚ç‚¹ç»„
            const node = g.append('g')
                .attr('class', 'nodes')
                .selectAll('g')
                .data(nodes)
                .enter()
                .append('g')
                .attr('class', 'node')
                .attr('transform', d => `translate(${d.x}, ${d.y})`)
                .call(d3.drag()
                    .on('start', dragStarted)
                    .on('drag', dragged)
                    .on('end', dragEnded));
            
            // ä¸ºæ¯ä¸ªèŠ‚ç‚¹åˆ›å»ºERå›¾é£æ ¼çš„çŸ©å½¢
            node.each(function(d) {
                const nodeGroup = d3.select(this);
                const isFile = d.source_type === 'file';
                const nodeWidth = isFile ? 100 : 90;
                const nodeHeight = isFile ? 60 : 50;
                
                // èŠ‚ç‚¹ä¸»ä½“
                nodeGroup.append('rect')
                    .attr('class', 'node-body')
                    .attr('width', nodeWidth)
                    .attr('height', nodeHeight)
                    .attr('x', -nodeWidth/2)
                    .attr('y', -nodeHeight/2)
                    .attr('fill', 'white')
                    .attr('stroke-width', 1.5);
                
                // èŠ‚ç‚¹å¤´éƒ¨ - ä½¿ç”¨ä¸åŒé¢œè‰²åŒºåˆ†ç±»å‹
                let headerColor;
                if (d.type === 'source') {
                    headerColor = '#10b981'; // ç»¿è‰²
                } else if (d.type === 'intermediate') {
                    headerColor = '#3b82f6'; // è“è‰²
                } else {
                    headerColor = '#f59e0b'; // æ©™è‰²
                }
                
                nodeGroup.append('rect')
                    .attr('width', nodeWidth)
                    .attr('height', 20)
                    .attr('x', -nodeWidth/2)
                    .attr('y', -nodeHeight/2)
                    .attr('fill', headerColor)
                    .attr('rx', 4)
                    .attr('ry', 4);
                
                // æ–‡ä»¶ç±»å‹ç‰¹æ®Šæ ‡è®°
                if (isFile) {
                    nodeGroup.append('text')
                        .attr('class', 'node-header')
                        .attr('y', -nodeHeight/2 + 10)
                        .text('FILE');
                } else {
                    nodeGroup.append('text')
                        .attr('class', 'node-header')
                        .attr('y', -nodeHeight/2 + 10)
                        .text(d.type === 'source' ? 'SOURCE' : d.type === 'intermediate' ? 'TABLE' : 'TARGET');
                }
                
                // èŠ‚ç‚¹å†…å®¹æ–‡æœ¬
                nodeGroup.append('text')
                    .attr('class', 'node-text')
                    .attr('y', isFile ? 5 : 0)
                    .text(d.displayName);
                
                // æ–‡ä»¶ç±»å‹æ˜¾ç¤ºæ–‡ä»¶å›¾æ ‡
                if (isFile) {
                    nodeGroup.append('text')
                        .attr('class', 'file-icon')
                        .attr('x', -nodeWidth/2 + 10)
                        .attr('y', nodeHeight/2 - 10)
                        .text('ğŸ“„');
                }
            });
            
            // æ·»åŠ èŠ‚ç‚¹æ‚¬åœæç¤º
            const tooltip = d3.select('body').append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);
            
            node.on('mouseover', function(event, d) {
                tooltip.transition()
                    .duration(200)
                    .style('opacity', .9);
                
                const typeText = d.type === 'source' ? 
                    (d.source_type === 'file' ? 'æºæ–‡ä»¶' : 'æºè¡¨') : 
                    d.type === 'intermediate' ? 'ä¸­é—´è¡¨' : 'ç›®æ ‡è¡¨';
                    
                tooltip.html(`
                    <div style="margin-bottom: 5px;"><strong>${d.name}</strong></div>
                    <div>ç±»å‹: ${typeText}</div>
                    <div>èŠ‚ç‚¹ç±»å‹: ${d.source_type === 'file' ? 'æ–‡ä»¶' : 'è¡¨'}</div>
                `)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 28) + 'px');
            })
            .on('mouseout', function() {
                tooltip.transition()
                    .duration(500)
                    .style('opacity', 0);
            });
            
            // åˆ›å»ºåŠ›å¯¼å‘å›¾ï¼ˆç”¨äºå¤„ç†é‡å å’Œå±‚æ¬¡æ„Ÿï¼‰
            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(150))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('collision', d3.forceCollide().radius(70))
                .force('x', d3.forceX().x(d => d.fx).strength(0.7))
                .force('y', d3.forceY().y(d => d.fy).strength(0.3))
                .on('tick', ticked);
            
            function ticked() {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                node
                    .attr('transform', d => `translate(${d.x}, ${d.y})`);
            }
            
            // æ‹–æ‹½å‡½æ•°
            function dragStarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            function dragEnded(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                // ä¿æŒxä½ç½®å›ºå®šï¼Œåªå…è®¸yæ–¹å‘ç§»åŠ¨
                d.fx = d.x;
            }
            
            // æ·»åŠ ç¼©æ”¾åŠŸèƒ½
            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', function(event) {
                    g.attr('transform', event.transform);
                });
            
            svg.call(zoom);
            
            // æ·»åŠ ç¼©æ”¾æ§åˆ¶æŒ‰é’®äº‹ä»¶
            document.getElementById('zoom-in').addEventListener('click', function() {
                svg.transition().call(zoom.scaleBy, 1.5);
            });
            
            document.getElementById('zoom-out').addEventListener('click', function() {
                svg.transition().call(zoom.scaleBy, 0.75);
            });
            
            document.getElementById('reset-zoom').addEventListener('click', function() {
                svg.transition().call(zoom.transform, d3.zoomIdentity);
            });
        }

        // ETLæµç¨‹æº¯æºè§†å›¾
        function renderETLLineage() {
            const container = document.getElementById('etl-lineage-chart');
            
            // æ£€æŸ¥æ•°æ®æ˜¯å¦å·²åŠ è½½
            if (!lineageData.etl || lineageData.etl.length === 0) {
                container.innerHTML = '<div class="error">ETLæµç¨‹æº¯æºæ•°æ®ä¸ºç©º</div>';
                return;
            }
            
            container.innerHTML = '';
            
            // æ·»åŠ ç¼©æ”¾æ§åˆ¶æŒ‰é’®
            const zoomControls = document.createElement('div');
            zoomControls.className = 'zoom-controls';
            zoomControls.innerHTML = `
                <button class="zoom-btn" id="zoom-in-etl">+</button>
                <button class="zoom-btn" id="zoom-out-etl">-</button>
                <button class="zoom-btn" id="reset-zoom-etl">â†º</button>
            `;
            container.appendChild(zoomControls);
            
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            const svg = d3.select('#etl-lineage-chart')
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            // åˆ›å»ºç¼©æ”¾å’Œå¹³ç§»å®¹å™¨
            const g = svg.append('g');
            
            // å¤„ç†æ•°æ® - æ„å»ºèŠ‚ç‚¹å’Œè¾¹
            const nodes = [];
            const links = [];
            const nodeMap = new Map();
            
            // è®¡ç®—èŠ‚ç‚¹å±‚çº§
            const nodeLevels = {};
            const maxLevels = 6;
            
            // åˆå§‹åŒ–æ‰€æœ‰è¡¨èŠ‚ç‚¹
            lineageData.etl.forEach(record => {
                if (!nodeMap.has(record.source_table)) {
                    // æ–‡ä»¶ç±»å‹èŠ‚ç‚¹æ˜¾ç¤ºå®Œæ•´æ–‡ä»¶åå’Œç±»å‹
                    let displayName = record.source_table;
                    if (record.source_type === 'file') {
                        displayName = record.source_table; // æ˜¾ç¤ºå®Œæ•´æ–‡ä»¶åï¼Œå¦‚test.csv
                    } else if (record.source_table.includes('.')) {
                        displayName = record.source_table.split('.')[1];
                    }
                    
                    nodes.push({
                        id: record.source_table,
                        name: record.source_table,
                        displayName: displayName,
                        type: 'table',
                        nodeType: 'table',
                        source_type: record.source_type
                    });
                    nodeMap.set(record.source_table, true);
                }
                
                if (!nodeMap.has(record.target_table)) {
                    nodes.push({
                        id: record.target_table,
                        name: record.target_table,
                        displayName: record.target_table.includes('.') ? 
                                    record.target_table.split('.')[1] : record.target_table,
                        type: 'table',
                        nodeType: 'table',
                        source_type: 'table'
                    });
                    nodeMap.set(record.target_table, true);
                }
            });
            
            // è®¡ç®—æ¯ä¸ªèŠ‚ç‚¹çš„å±‚çº§ï¼ˆä»æºå¤´å¼€å§‹ï¼‰
            function calculateLevels() {
                // åˆå§‹åŒ–å±‚çº§
                nodes.forEach(node => {
                    nodeLevels[node.id] = -1;
                });
                
                // æ‰¾åˆ°æ‰€æœ‰æºå¤´èŠ‚ç‚¹ï¼ˆæ²¡æœ‰è¾“å…¥è¾¹çš„èŠ‚ç‚¹ï¼‰
                const sourceNodes = nodes.filter(node => {
                    return !lineageData.etl.some(record => record.target_table === node.id);
                });
                
                // ä»æºå¤´èŠ‚ç‚¹å¼€å§‹åˆ†é…å±‚çº§
                sourceNodes.forEach(node => {
                    nodeLevels[node.id] = 0;
                    propagateDownstream(node.id, 0);
                });
                
                // å¤„ç†å¯èƒ½é—æ¼çš„èŠ‚ç‚¹
                nodes.forEach(node => {
                    if (nodeLevels[node.id] === -1) {
                        // æ‰¾åˆ°æœ€å°å¯èƒ½çš„å±‚çº§
                        const incomingRecords = lineageData.etl.filter(record => record.target_table === node.id);
                        if (incomingRecords.length > 0) {
                            const minSourceLevel = Math.min(...incomingRecords.map(record => nodeLevels[record.source_table]));
                            nodeLevels[node.id] = minSourceLevel + 1;
                            propagateDownstream(node.id, minSourceLevel + 1);
                        } else {
                            nodeLevels[node.id] = 0;
                        }
                    }
                });
                
                // å‘ä¸‹æ¸¸ä¼ æ’­å±‚çº§
                function propagateDownstream(table, level) {
                    if (level > maxLevels) return;
                    
                    lineageData.etl.forEach(record => {
                        if (record.source_table === table && nodeLevels[record.target_table] < level + 1) {
                            nodeLevels[record.target_table] = level + 1;
                            propagateDownstream(record.target_table, level + 1);
                        }
                    });
                }
            }
            
            calculateLevels();
            
            // åˆ›å»ºETLèŠ‚ç‚¹å’Œè¾¹çš„æ˜ å°„
            const etlNodeMap = new Map();
            
            // æ·»åŠ ETLèŠ‚ç‚¹å’Œè¾¹
            lineageData.etl.forEach(record => {
                // ä¸ºæ¯ä¸ªETLæµç¨‹åˆ›å»ºä¸€ä¸ªèŠ‚ç‚¹ï¼ˆå¦‚æœè¿˜ä¸å­˜åœ¨ï¼‰
                const etlNodeId = record.etl_desc;
                if (!etlNodeMap.has(etlNodeId)) {
                    nodes.push({
                        id: etlNodeId,
                        name: record.etl_desc,
                        displayName: record.etl_desc,
                        type: 'etl',
                        nodeType: 'etl',
                        target_table: record.target_table,
                        created_at: record.created_at,
                        workflow_code: record.workflow_code
                    });
                    etlNodeMap.set(etlNodeId, {
                        nodeId: etlNodeId,
                        sources: [],
                        target: record.target_table
                    });
                    
                    // ETLèŠ‚ç‚¹çš„å±‚çº§åœ¨æºè¡¨å’Œç›®æ ‡è¡¨ä¹‹é—´
                    const sourceLevel = nodeLevels[record.source_table];
                    const targetLevel = nodeLevels[record.target_table];
                    nodeLevels[etlNodeId] = (sourceLevel + targetLevel) / 2;
                }
                
                // æ·»åŠ æºè¡¨åˆ°ETLèŠ‚ç‚¹çš„æ˜ å°„
                const etlNode = etlNodeMap.get(etlNodeId);
                if (!etlNode.sources.includes(record.source_table)) {
                    etlNode.sources.push(record.source_table);
                }
            });
            
            // æ ¹æ®ETLèŠ‚ç‚¹æ˜ å°„åˆ›å»ºè¾¹
            etlNodeMap.forEach((etlNode, etlNodeId) => {
                // æ‰¾åˆ°ETLèŠ‚ç‚¹å¯¹è±¡
                const etlNodeObj = nodes.find(n => n.id === etlNodeId);
                
                // ä¸ºæ¯ä¸ªæºè¡¨åˆ›å»ºè¾¹ï¼šæºè¡¨ -> ETLæµç¨‹
                etlNode.sources.forEach(sourceTable => {
                    const sourceNode = nodes.find(n => n.id === sourceTable);
                    if (sourceNode && etlNodeObj) {
                        links.push({
                            source: sourceNode,
                            target: etlNodeObj,
                            type: 'source_to_etl'
                        });
                    }
                });
                
                // åˆ›å»ºè¾¹ï¼šETLæµç¨‹ -> ç›®æ ‡è¡¨
                const targetNode = nodes.find(n => n.id === etlNode.target);
                if (targetNode && etlNodeObj) {
                    links.push({
                        source: etlNodeObj,
                        target: targetNode,
                        type: 'etl_to_target'
                    });
                }
            });
            
            // è®¾ç½®èŠ‚ç‚¹ä½ç½®ï¼ˆæŒ‰å±‚çº§ä»å·¦åˆ°å³æ’åˆ—ï¼‰
            const levelWidth = width / (maxLevels + 1);
            const levelPositions = {};
            
            nodes.forEach(node => {
                const level = nodeLevels[node.id] !== undefined ? nodeLevels[node.id] : 0;
                if (!levelPositions[level]) levelPositions[level] = [];
                levelPositions[level].push(node);
            });
            
            // ä¸ºæ¯ä¸ªå±‚çº§çš„èŠ‚ç‚¹åˆ†é…Yåæ ‡
            Object.keys(levelPositions).forEach(level => {
                const nodesInLevel = levelPositions[level];
                const levelHeight = height / (nodesInLevel.length + 1);
                
                nodesInLevel.forEach((node, index) => {
                    node.x = level * levelWidth + levelWidth / 2;
                    node.y = (index + 1) * levelHeight;
                    node.fx = node.x;
                    node.fy = node.y;
                });
            });
            
            // åˆ›å»ºç®­å¤´æ ‡è®°
            svg.append('defs').selectAll('marker')
                .data(['arrowhead'])
                .enter().append('marker')
                .attr('id', d => d)
                .attr('viewBox', '0 -5 10 10')
                .attr('refX', 15)
                .attr('refY', 0)
                .attr('markerWidth', 6)
                .attr('markerHeight', 6)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M0,-5L10,0L0,5')
                .attr('fill', '#a0aec0');
            
            // åˆ›å»ºè¾¹
            const link = g.append('g')
                .attr('class', 'links')
                .selectAll('line')
                .data(links)
                .enter()
                .append('line')
                .attr('class', 'link')
                .attr('marker-end', d => d.type === 'etl_to_target' ? 'url(#arrowhead)' : '');
            
            // åˆ›å»ºèŠ‚ç‚¹ç»„
            const node = g.append('g')
                .attr('class', 'nodes')
                .selectAll('g')
                .data(nodes)
                .enter()
                .append('g')
                .attr('class', 'node')
                .attr('transform', d => `translate(${d.x}, ${d.y})`)
                .call(d3.drag()
                    .on('start', dragStarted)
                    .on('drag', dragged)
                    .on('end', dragEnded));
            
            // ä¸ºæ¯ä¸ªèŠ‚ç‚¹åˆ›å»ºERå›¾é£æ ¼çš„çŸ©å½¢
            node.each(function(d) {
                const nodeGroup = d3.select(this);
                const isTable = d.nodeType === 'table';
                const isFile = d.source_type === 'file';
                const nodeWidth = isTable ? (isFile ? 100 : 90) : 110;
                const nodeHeight = isTable ? (isFile ? 60 : 50) : 60;
                
                // èŠ‚ç‚¹ä¸»ä½“
                nodeGroup.append('rect')
                    .attr('class', 'node-body')
                    .attr('width', nodeWidth)
                    .attr('height', nodeHeight)
                    .attr('x', -nodeWidth/2)
                    .attr('y', -nodeHeight/2)
                    .attr('fill', 'white')
                    .attr('stroke-width', 1.5);
                
                // èŠ‚ç‚¹å¤´éƒ¨ - ä½¿ç”¨ä¸åŒé¢œè‰²åŒºåˆ†ç±»å‹
                let headerColor;
                if (isTable) {
                    headerColor = '#10b981'; // è¡¨èŠ‚ç‚¹ä½¿ç”¨ç»¿è‰²
                } else {
                    headerColor = '#8b5cf6'; // ETLèŠ‚ç‚¹ä½¿ç”¨ç´«è‰²
                }
                
                nodeGroup.append('rect')
                    .attr('width', nodeWidth)
                    .attr('height', 20)
                    .attr('x', -nodeWidth/2)
                    .attr('y', -nodeHeight/2)
                    .attr('fill', headerColor)
                    .attr('rx', 4)
                    .attr('ry', 4);
                
                // è¡¨èŠ‚ç‚¹æˆ–æ–‡ä»¶èŠ‚ç‚¹çš„ç‰¹æ®Šæ ‡è®°
                if (isTable) {
                    if (isFile) {
                        nodeGroup.append('text')
                            .attr('class', 'node-header')
                            .attr('y', -nodeHeight/2 + 10)
                            .text('FILE');
                    } else {
                        nodeGroup.append('text')
                            .attr('class', 'node-header')
                            .attr('y', -nodeHeight/2 + 10)
                            .text('TABLE');
                    }
                } else {
                    // ETLèŠ‚ç‚¹
                    nodeGroup.append('text')
                        .attr('class', 'node-header')
                        .attr('y', -nodeHeight/2 + 10)
                        .text('ETL');
                }
                
                // èŠ‚ç‚¹å†…å®¹æ–‡æœ¬
                nodeGroup.append('text')
                    .attr('class', 'node-text')
                    .attr('y', isTable ? (isFile ? 5 : 0) : 5)
                    .text(d.displayName);
                
                // æ–‡ä»¶ç±»å‹æ˜¾ç¤ºæ–‡ä»¶å›¾æ ‡
                if (isFile) {
                    nodeGroup.append('text')
                        .attr('class', 'file-icon')
                        .attr('x', -nodeWidth/2 + 10)
                        .attr('y', nodeHeight/2 - 10)
                        .text('ğŸ“„');
                }
            });
            
            // æ·»åŠ èŠ‚ç‚¹æ‚¬åœæç¤º
            const tooltip = d3.select('body').append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);
            
            node.on('mouseover', function(event, d) {
                tooltip.transition()
                    .duration(200)
                    .style('opacity', .9);
                
                if (d.nodeType === 'table') {
                    const typeText = d.source_type === 'file' ? 'æºæ–‡ä»¶' : 'è¡¨';
                    tooltip.html(`
                        <div style="margin-bottom: 5px;"><strong>${d.name}</strong></div>
                        <div>èŠ‚ç‚¹ç±»å‹: ${typeText}</div>
                    `);
                } else {
                    // è·å–ETLèŠ‚ç‚¹çš„æºè¡¨åˆ—è¡¨
                    const etlNode = etlNodeMap.get(d.id);
                    const sourcesList = etlNode ? etlNode.sources.map(s => `<li>${s}</li>`).join('') : '';
                    
                    tooltip.html(`
                        <div style="margin-bottom: 5px;"><strong>${d.name}</strong></div>
                        <div>èŠ‚ç‚¹ç±»å‹: ETLæµç¨‹</div>
                        <div>æºè¡¨: <ul style="margin: 5px 0; padding-left: 15px;">${sourcesList}</ul></div>
                        <div>ç›®æ ‡è¡¨: ${d.target_table}</div>
                        <div>å·¥ä½œæµ: ${d.workflow_code}</div>
                        <div>åˆ›å»ºæ—¶é—´: ${d.created_at}</div>
                    `);
                }
                
                tooltip.style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 28) + 'px');
            })
            .on('mouseout', function() {
                tooltip.transition()
                    .duration(500)
                    .style('opacity', 0);
            });
            
            // åˆ›å»ºåŠ›å¯¼å‘å›¾ï¼ˆç”¨äºå¤„ç†é‡å å’Œå±‚æ¬¡æ„Ÿï¼‰
            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(150))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('collision', d3.forceCollide().radius(70))
                .force('x', d3.forceX().x(d => d.fx).strength(0.7))
                .force('y', d3.forceY().y(d => d.fy).strength(0.3))
                .on('tick', ticked);
            
            function ticked() {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                node
                    .attr('transform', d => `translate(${d.x}, ${d.y})`);
            }
            
            // æ‹–æ‹½å‡½æ•°
            function dragStarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            function dragEnded(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                // ä¿æŒxä½ç½®å›ºå®šï¼Œåªå…è®¸yæ–¹å‘ç§»åŠ¨
                d.fx = d.x;
            }
            
            // æ·»åŠ ç¼©æ”¾åŠŸèƒ½
            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', function(event) {
                    g.attr('transform', event.transform);
                });
            
            svg.call(zoom);
            
            // æ·»åŠ ç¼©æ”¾æ§åˆ¶æŒ‰é’®äº‹ä»¶
            document.getElementById('zoom-in-etl').addEventListener('click', function() {
                svg.transition().call(zoom.scaleBy, 1.5);
            });
            
            document.getElementById('zoom-out-etl').addEventListener('click', function() {
                svg.transition().call(zoom.scaleBy, 0.75);
            });
            
            document.getElementById('reset-zoom-etl').addEventListener('click', function() {
                svg.transition().call(zoom.transform, d3.zoomIdentity);
            });
        }

        // åˆå§‹åŒ–è§†å›¾
        document.addEventListener('DOMContentLoaded', function() {
            // æ˜¾ç¤ºAPI URL
            document.getElementById('api-url').textContent = API_BASE_URL;
            
            // åŠ è½½æ•°æ®
            loadAllData();
            
            // åˆ·æ–°æ•°æ®æŒ‰é’®
            document.getElementById('refresh-data').addEventListener('click', function() {
                loadAllData();
            });
            
            // é‡ç½®è§†å›¾æŒ‰é’®
            document.getElementById('reset-view').addEventListener('click', function() {
                const activeView = document.querySelector('.view.active').id;
                if (activeView === 'table-lineage') {
                    renderTableLineage();
                } else {
                    renderETLLineage();
                }
            });
            
            // æœç´¢åŠŸèƒ½
            document.getElementById('search-input').addEventListener('input', function(e) {
                const searchTerm = e.target.value.toLowerCase();
                // è¿™é‡Œå¯ä»¥æ·»åŠ æœç´¢é«˜äº®é€»è¾‘
                console.log('æœç´¢:', searchTerm);
            });
        });
    </script>
</body>
</html>